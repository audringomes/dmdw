#% text_encoding = iso8859_1
# ************************************************************
#
# (c) 2020 Realworld Software Products. All Rights Reserved.
#
# ************************************************************

_package sw

_pragma(classify_level=basic, topic={dmdw,dm_doc_writer})
##
## This class offers a way to perform the translation from XML
## to HTML using XSLT. Run by transform_to_html()
##
## The class acts as singleton. No instantiation necessary.
##
## If path_to_exe is unset, it will use the java saxon 
## processor in the bin directory. 
##
def_slotted_exemplar(:dm_xml_transformer,{})
$

_pragma(classify_level=basic, topic={dmdw,dm_doc_writer})
##
## If set, this saxon processor will be used rather than the
## java version in the module bin folder.
## Eg "C:\Program Files\Saxonica\SaxonHE10.2N\bin\Transform.exe"
##
dm_xml_transformer.define_shared_constant(:path_to_saxon_exe,
	_unset,
	:public)
$

_pragma(classify_level=basic, topic={dmdw,dm_doc_writer})
_method dm_xml_transformer.transform_to_html(p_module_name, p_input_file, _optional 
					     p_output_dir,
					     p_stylesheet,
					     p_copy_html_resources?,
					     p_copy_help?,
					     p_svg_filename)
	
	## 
	## Do a XSLT transform on xml file P_INPUT_FILE in module
	## P_MODULE_NAME using the XLST file P_STYLESHEET.
	##
	## P_INPUT_FILE should be in base/xml resource of P_MODULE_NAME.
	## P_OUTPUT_DIR defaults to the base/html_output resource
	## folder of module P_MODULE_NAME or, when this 
	## does not exist, the directory of P_INPUT_FILE.
	##
	## P_STYLESHEET is the name of the xsl stylesheet to use. This
	## defaults to FileSet2.xsl in the data/xsl of the module
	## :dm_doc_writer.
	## If P_STYLESHEET is an absolute path, that file will be used.
	##
	## P_COPY_HTML_RESOURCES? If true (default is _true) it will
	## copy the resources in the data/html folder of
	## dm_doc_writer into P_OUTPUT_DIR
	##
	## P_COPY_HELP? If true (default is _true) it copies the help
	## resources of the module into P_OUTPUT_DIR
	##
	## P_SVG_FILENAME is the name of a SVG file to include.
	##
	## THE method returns the full outputpath of the html.
	##

	_if (l_module << sw_module_manager.module(p_module_name)) _is _unset 
	_then condition.raise(:error,:string,write_string("Module ",p_module_name," does not exist!"))
	_else write("Processing from resources in module ",l_module)
	_endif
	
	_local l_input_path << l_module.get_resource_file(p_input_file,:xml)
	_local (l_input_filename,l_input_dir) << system.pathname_components(l_input_path)

	write("Transforming ",l_input_path,"...")

	_local l_xsl_path << _self.xsl_file( l_module,p_stylesheet.default("FileSet2.xsl"))
	write("Using xsl stylesheet ",l_xsl_path)

	_if p_svg_filename _isnt _unset 
	_then
		write("Include svg document ",p_svg_filename)
	_endif
	
	_local l_output_path << _unset
	_if p_output_dir _is _unset 
	_then
		_if (l_list << l_module.resource_list_for(:html_output,_false)).size > 0
		_then
			l_output_dir << l_list.an_element()
			l_output << system.pathname_from_components(l_input_filename,l_output_dir)
			( base, ext ) << system.split_filename(l_output)
			l_output_path << system.check_filename_extension(base,".html")
		_else
			( base, ext ) << system.split_filename(l_input_filename)
			l_output_path << system.check_filename_extension(base,".html")
		_endif
		
	_else
		l_output_dir << p_output_dir
		l_output << system.pathname_from_components(l_input_filename,l_output_dir)
		( base, ext ) << system.split_filename(l_output)
		l_output_path << system.check_filename_extension(base,".html")
	_endif
	
	write("To file ",l_output_path)

	# Pass name and full path of svg to enable copy-of in xslt
	_self.do_transform( l_input_path, l_xsl_path, l_output_path, p_svg_filename)

	_if p_copy_html_resources?.default(_true) _is _true 
	_then
		_try _with cond
			_self.copy_resources( l_module, system.pathname_up(l_output_path) ,:html)		
		_when error
			write("Copy failed ",cond.report_contents_string)
		_endtry

	_endif

	_if p_copy_help?.default(_true) _is _true 
	_then
		_self.copy_help(l_module,l_output_path)
	_endif

	write("Created ",l_output_path)
	
	>> l_output_path
	
_endmethod
$

_pragma(classify_level=basic, topic={dmdw,dm_doc_writer})
_private _method dm_xml_transformer.do_transform( p_input_path, p_xsl_path, p_output_path, _optional p_svg_path )
	## 
	## 

	_if p_svg_path _isnt _unset 
	_then (l_svg_name,l_svg_path) << system.pathname_components(p_svg_path)
	_endif

	_if (l_exe_path << _self.path_to_saxon_exe) _is _unset 
	_then l_exe_path << _self.java_command_string
	_endif
	
	_local (l_fname,l_dir) << system.pathname_components(p_output_path)
	_local l_command << write_string(l_exe_path,
					 " -s:",p_input_path,
					 " -xsl:",p_xsl_path,
					 " -o:",p_output_path,
					 " OFileName=",l_fname,
					 " SVGName=",l_svg_name.default(""),
					 " SVGPath=",p_svg_path.default(""))
					 
	
	write("Executing command ",l_command)

	(status,error_code) << system.do_command( l_command )
	
	_if error_code _isnt 0
	_then condition.raise(:error,:string,write_string("Process failed and returned error ",error_code))
	_else write("Saxon process finished")
	_endif

_endmethod
$

_pragma(classify_level=basic, topic={dmdw,dm_doc_writer})
_method dm_xml_transformer.copy_help(p_module,p_output_file)
	##
	## Copies the help from P_MODULE or from module dm_doc_writer to
	## the html output, so help can be retrieved from the html pages.
	## 
	## P_MODULE is the module that might contain help resources.
	## P_OUTPUT_FILE is the path of the html file that is generated.
	## 

	_local l_return << _false
	
	# Get help if defined from module P_MODULE_NAME
	_local indexfile
	_try _with cond
		indexfile << smallworld_product.get_resource_file("index.html","help",p_module.name)
		write("HELP Resource found ",indexfile)
	_when resource_not_found_in_module_error
		write("No HELP resource found ",cond.report_contents_string)
	_endtry

	# Get the help from dm_doc_writer
	_if indexfile _is _unset
	_then 
		_try _with cond
			indexfile << smallworld_product.get_resource_file("index.html","help","dm_doc_writer")
			write("Default HELP Resource found ",indexfile)
		_when resource_not_found_in_module_error
			write("ERROR - No HELP resource found ",cond.report_contents_string)
		_endtry
	_endif
	
	_if indexfile _is _unset
	_then _return l_return
	_endif

	_local (l_name,l_dir) << system.pathname_components(indexfile)
	_local (l_outname,l_outdir) << system.pathname_components(p_output_file)
	_local l_helpdir << system.pathname_down(l_outdir,"help")
	
	_if _not system.file_exists?(l_helpdir)
	_then
		system.mkdir(l_helpdir)
	_endif

#	_local l_log_file << system.pathname_from_components("DMDW_COPY.log",l_helpdir)
	_local l_cmd << write_string("XCOPY /Y /E /EXCLUDE:exclude_from_copy.txt ",
				     system.canonicalise(l_dir),"\*.* ",
				     system.canonicalise(l_helpdir),"\ ")
	
	_try _with cond
		write("Copy command ",l_cmd)
		system.do_command(l_cmd,l_dir)
		l_return << _true 
	_when error
		write("Copy of help from ",l_dir," to ",l_helpdir," failed ",cond.report_contents_string)
	_endtry

	>> l_return
_endmethod
$

_pragma(classify_level=restricted, topic={dmdw,dm_doc_writer})
_private _method dm_xml_transformer.copy_resources( p_module, p_output_dir, p_type )
	##
	## Copies webresources to P_OUTPUT_DIR
	## It will 1st copy from the module DS_DOC_WRITER and then from
	## the module resources of P_MODULE
	##

	write("Copying ",p_type," resources from ",p_module," to ",p_output_dir)
	_for i_module _over {sw_module_manager.module(:dm_doc_writer),p_module}.fast_elements()
	_loop 

		_if (l_dir << i_module.resource_list_for(p_type).an_element()) _isnt _unset 
		_then 
			write("Copy ",p_type," resources from ",i_module)
			_local l_chan << directory_channel.new(l_dir)
			_loop
				_if (l_file << l_chan.get()) _is _unset 
				_then
					_leave 
				_else
					l_old << system.pathname_from_components(l_file,l_dir)
					l_new << system.pathname_from_components(l_file,p_output_dir)
					# write("Copying ",l_old," to ",l_new)
					system.file_copy(l_old,l_new)
				_endif
			_endloop
		_endif
		
	_endloop

_endmethod
$

_pragma(classify_level=restricted, topic={dmdw,dm_doc_writer})
_method dm_xml_transformer.java_command_string
	## 
	## Return a string to be used by system.do_command to run the saxon java processor.
	## Parameters need to be added.
	##
	
	l_cmd << system.canonicalise("/bin/java.exe",system.getenv("JAVA_HOME"))
	l_mod << sw_module_manager.module(_self.module_name.default(:dm_doc_writer))
	l_bin << l_mod.resource_list_for(:bin).an_element()
	l_can << directory_channel.new(l_bin,"saxon-he-*.jar")
	_if (l_name << l_can.get()) _isnt _unset 
	_then 
		l_cmd << write_string(l_cmd," -cp ",
				      system.canonicalise(l_name,l_bin),
				      " net.sf.saxon.Transform ")
	_endif
	>> l_cmd
	
_endmethod
$

_pragma(classify_level=restricted, topic={dmdw,dm_doc_writer})
_private _method dm_xml_transformer.xsl_file( p_module, p_name)
	## 
	## 

	_local l_xsl_path

	_for i_module _over { p_module, sw_module_manager.module(_self.module_name) }.fast_elements()
	_loop
		_try _with p_cond
			l_xsl_path << i_module.get_resource_file( p_name, :xsl )
		_when error
			write(p_cond.report_contents_string)
		_endtry
	_endloop

	_if l_xsl_path _is _unset 
	_then condition.raise(:error,:string,write_string("XSL file '",p_name,"' not found"))
	_endif
	
	>> l_xsl_path
	
_endmethod
$

_pragma(classify_level=restricted, topic={dmdw,dm_doc_writer})
_method dm_xml_transformer.svg_for_xml( p_xml_path )
	## 
	## Returns csv filename and full pathname if there exists a
	## .csv file with the same name as the file P_XML_PATH
	## P_XML_PATH full pathname of xml. Note that the \ must be
	## replaced by /
	##
	
	_local (l_fname,l_dir) << system.pathname_components( p_xml_path)
	_local (l_name,l_ext) << system.split_filename( l_fname )
	_local l_svg_name << write_string(l_name,".svg")
	_local l_svg_path << system.pathname_from_components(l_svg_name,l_dir)
	l_svg_path << l_svg_path.replace_all_instances_of("\","/")
		
	_if system.file_exists?(l_svg_path)
	_then _return l_svg_name, l_svg_path
	_else write(l_svg_path," not found ")
	_endif

_endmethod
$

_pragma(classify_level=restricted, topic={dmdw,dm_doc_writer})
_method dm_xml_transformer.create_index_page( p_module, p_files)
	## 
	## Create an index file for DMDW ds HTML pages
	## P_FILES is a collection with {xml_file,html_file} pairs
	## 

	#DEBUG print(p_files)

	_local l_dir << p_module.resource_list_for(:html_output).an_element()
	_local l_xml_name << system.pathname_from_components("index.xml",l_dir)
	_local l_xsl_name << _self.xsl_file( p_module, "index.xsl" )
	_local l_html_name << system.pathname_from_components("index.html",l_dir)

	write("Creating index page... ")

	_local l_xml << dm_xml_handler.create_index_xml( l_xml_name, p_files )
	simple_xml.write_element_file( l_xml_name, l_xml )

	_self.do_transform( l_xml_name, l_xsl_name , l_html_name )	
	
	_local l_html << l_html_name
	
	>> l_html
_endmethod
$
